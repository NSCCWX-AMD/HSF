/**
* @file: 
* @author: Liu Hongbin
* @brief: 
* @date:   2019-10-14 09:17:17
* @last Modified by:   lenovo
* @last Modified time: 2019-11-13 00:47:16
*/
#include <algorithm>
#include "region.hpp"

using namespace std;

namespace HSF
{

bool compare(pair<label, pair<label, label> > a, pair<label, pair<label, label> > b)
{
    if(a.first == b.first)
    {
        if(a.second.first ==  b.second.first)
        {
            return a.second.second <  b.second.second;
        }

        return a.second.first < b.second.first;
    }

    return a.first < b.first;
}


void Region::initBeforeBalance(char* meshFile)
{
	strncpy(meshFile_, meshFile, sizeof(meshFile_));
	// this->meshFile_[sizeof(meshFile)-1]='/0';
	this->getMesh().readMesh(meshFile);
	MPI_Barrier(MPI_COMM_WORLD);
}

void Region::initAfterBalance()
{
	this->getMesh().getTopology().constructTopology();
	MPI_Barrier(MPI_COMM_WORLD);

	/// 创建通信对
	Label cellNum = this->getMesh().getTopology().getCellsNum();
	Array<Array<Label> > faceCells
		= this->getMesh().getTopology().getFace2CellPatch();

    int nprocs, rank;

    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
 //    for (int i = 0; i < nprocs; ++i)
 //    {
 //    	if(rank==i)
 //    	{
 //    		printf("rank: %d\n", rank);
	//     	for (int j = 0; j < faceCells.size(); ++j)
	// 		{
	// 			printf("The %dth face: ", j);
	// 			for (int k = 0; k < faceCells[j].size(); ++k)
	// 			{
	// 				printf("%d, ", faceCells[j][k]);
	// 			}
	// 			printf("\n");
	// 		}
	// 	}
	// 	MPI_Barrier(MPI_COMM_WORLD);
	// }
	createInterFaces(faceCells, cellNum);


	this->getBoundary().readMesh(this->meshFile_);
	Topology innerTopo = this->getMesh().getTopology();
	this->getBoundary().exchangeBoundaryElements(innerTopo);
}

void Region::write(char* meshFile, Label* field)
{
	this->getMesh().writeMesh(meshFile, field);
	this->getBoundary().writeMesh(meshFile, field);
}

void Region::writeField(char* fieldName)
{

}

/// guhf
void Region::createInterFaces
(
    Array<Array<label> >& faceCells,
    label cellNum
)
{
    int nProcs, myProcNo;

    MPI_Comm_size(MPI_COMM_WORLD, &nProcs);
    MPI_Comm_rank(MPI_COMM_WORLD, &myProcNo);

    label* partitionInfo = new label[nProcs + 1];
    MPI_Allgather
    (
        &cellNum,
        1,
        MPI_LABEL,
        &partitionInfo[1],
        1,
        MPI_LABEL,
        MPI_COMM_WORLD
    );
    partitionInfo[0] = 0;
    for (int i = 0; i < nProcs; ++i)
    {
    	partitionInfo[i+1] += partitionInfo[i];
    }
    // partitionInfo[nProcs] = nCellsAll - 1;
    label nCellsAll = partitionInfo[nProcs];

    if(!patchTabPtr_)
    {
        //- create
        patchTabPtr_ = new Table<Word, Table<Word, Patch*>*>;
    }

    Table<Word, Table<Word, Patch*>*>& allPatchTab = *patchTabPtr_;

    Word patchType = "face";

    allPatchTab[patchType] = new Table<Word, Patch*>;

    Table<label, label> facesInProcessor;
    Array< pair<label, pair<label, label> > > vec;

    for(label i=0; i<faceCells.size(); ++i)
    {
        label IDIn, IDOut;
        IDIn = faceCells[i][0];
        IDOut = faceCells[i][1];

        bool FIND = false;
        //- get the assumed neighbor processor ID,
        //- by assuming that all cells are partitioned uniformly
        label procAssume = IDOut / (nCellsAll / nProcs);

        if(IDOut < nCellsAll)
        {
            //- if the assumed processor ID is larger than the
            //- biggest processor ID, then
            if(procAssume > nProcs - 1) procAssume = nProcs - 1;
                do
                {
                    if(IDOut >= partitionInfo[procAssume + 1])
                    {
                        procAssume++;
                    }
                    else if(IDOut < partitionInfo[procAssume])
                    {
                        procAssume--;
                    }
                    else
                    {
                        //- do nothing
                        FIND = true;
                    }
                }while(!FIND);
        }
        else
        {
            printf("Error: cell ID exceeds the total cell number: cell ID = %d, total number = %d!\n", IDOut, nCellsAll);
        }

        //- smaller IDs are placed in the left
        //- thus all processors will follow the same discipline
        //- and produce the same patch faces order
        if(IDIn > IDOut)
        {
            int temp = IDIn;
            IDIn = IDOut;
            IDOut = temp;
        }

        vec.push_back(make_pair(procAssume, make_pair(IDIn, IDOut)));
    }

    //- sort faces in order of neighbor processors
    std::sort(vec.begin(), vec.end(), compare);

    Table<label, Array<label> > patchMap;

    //- split the faces in order of neighbor processors
    for (label i = 0; i < vec.size(); ++i)
    {
        label NbrProcID = vec[i].first;
        label cellID1 = vec[i].second.first;
        label cellID2 = vec[i].second.second;
        label localCellID;

        //- find the cellIDs belonging to current processor
        //- and storage them
        if(cellID1 >= partitionInfo[myProcNo] &&
           cellID1 <  partitionInfo[myProcNo+1])
        {
            localCellID = cellID1;
        }
        else if(cellID2 >= partitionInfo[myProcNo] &&
                cellID2 <  partitionInfo[myProcNo+1])
        {
            localCellID = cellID2;
        }
        else if(cellID2 == partitionInfo[myProcNo+1])
        {
            localCellID = cellID2;
        }
        else
        {
            printf("Error: cell is not in the target Processor, please check! At proc = %d, cell1 = %d, cell2 = %d\n", myProcNo, cellID1, cellID2);
        }

        patchMap[NbrProcID].push_back(localCellID);
    }

    Table<Word, Patch*>& patches = *allPatchTab[patchType];
    Table<label, Array<label> >::iterator it;
    for(it = patchMap.begin(); it!=patchMap.end(); it++)
    {
        label nbrID = it->first;
        label faceSize = (it->second).size();

        label* face2CellIDs = new label[faceSize];
        Array<label> array1 = it->second;

        for(label j=0; j<faceSize; ++j)
        {
            face2CellIDs[j] = array1[j];
        }
        //- construct the patch
        patches[to_string(nbrID)] = new Patch(faceSize, face2CellIDs, nbrID);
        DELETE_POINTER(face2CellIDs);
    }
}


void Region::initFields(Word fieldName)
{
    // Table<Word, scalarField*>::iterator it = fieldTable_.find(fieldName);
    // if(it == fieldTable_.end())
    // {
    //  cout << "Error: can not find this field: " << fieldName << endl;
    //  ERROR_EXIT;
    // }

    // scalarField* fieldSend = it->second;
    // Word fieldType = fieldSend->getType();

    // //- choose proper interface: face, node

    // for(label i=0; i<interFaces_.size(); ++i)
    // {
    //  Patch* pp = interFaces_[i].second;
    //  Word patchType = pp->getType();
    //  if(fieldType == patchType)
    //  {
    //      pp.send(*fieldSend);
    //  }
    // }
}

void Region::updateFields(Word fieldName)
{
    // Table<Word, scalarField*>::iterator it = fieldTable_.find(fieldName);
    // if(it == fieldTable_.end())
    // {
    //  cout << "Error: can not find this field: " << fieldName << endl;
    //  ERROR_EXIT;
    // }

    // scalarField* fieldSend = it->second;
    // Word fieldType = fieldSend->getType();

}



Region::~Region()
{
    //- free interfaces created

    //- delete Table<Word, Table<Word, Patch*>*>*
    if(patchTabPtr_)
    {
        Table<Word, Table<Word, Patch*>*>& allPatchTab = *patchTabPtr_;
        Table<Word, Table<Word, Patch*>*>::iterator it1;

        //- delete Table<Word, Patch*>*
        for(it1= allPatchTab.begin(); it1!=allPatchTab.end(); it1++)
        {
            Table<Word, Patch*>* patchesPtr = it1->second;
            Table<Word, Patch*>& patches = *patchesPtr;
            Table<Word, Patch*>::iterator it2;
            //- delete Patch*
            for(it2=patches.begin(); it2!=patches.end(); it2++)
            {
                Patch* patchIPtr = it2->second;
                DELETE_OBJECT_POINTER(patchIPtr);
            }
            DELETE_OBJECT_POINTER(patchesPtr)
        }
        DELETE_OBJECT_POINTER(patchTabPtr_);
    }
}

labelField& Region::getLabelField(Word fieldType, Word fieldName)
{
    if(!labelFieldTabPtr_)
    {
        printf("Filed is not yet built\n");
    }

    Table<Word, Table<Word, labelField*>*>::iterator it1 = (*labelFieldTabPtr_).find(fieldType);

    if(it1 == (*labelFieldTabPtr_).end())
    {
        cout << "There is no this type in field table: " << fieldType << endl;
    }
    else
    {
        Table<Word, labelField*>& fields = *((*labelFieldTabPtr_)[fieldType]);

        Table<Word, labelField*>::iterator it2 = fields.find(fieldName);

        if(it2 == fields.end())
        {
            cout << "There is no this type in field table: " << fieldName << endl;
        }
        else
        {
            labelField& fieldI = *(fields[fieldName]);
            return fieldI;
        }
    }
}

scalarField& Region::getScalarField(Word fieldType, Word fieldName)
{
    if(!scalarFieldTabPtr_)
    {
        printf("Filed is not yet built\n");
    }

    Table<Word, Table<Word, scalarField*>*>::iterator it1 = (*scalarFieldTabPtr_).find(fieldType);

    if(it1 == (*scalarFieldTabPtr_).end())
    {
        cout << "There is no this type in field table: " << fieldType << endl;
    }
    else
    {
        Table<Word, scalarField*>& fields = *((*scalarFieldTabPtr_)[fieldType]);

        Table<Word, scalarField*>::iterator it2 = fields.find(fieldName);

        if(it2 == fields.end())
        {
            cout << "There is no this type in field table: " << fieldName << endl;
        }
        else
        {
            scalarField& fieldI = *(fields[fieldName]);
            return fieldI;
        }
    }
}

void Region::addLabelField
(
    Word setType,
    Word name,
    labelField* f
)
{
    if(!labelFieldTabPtr_)
    {
        labelFieldTabPtr_ = new Table<Word, Table<Word, labelField*>*>;
    }

    if(!(*labelFieldTabPtr_)[setType])
    {
        (*labelFieldTabPtr_)[setType] = new Table<Word, labelField*>;
    }

    Table<Word, labelField*>& fields = *((*labelFieldTabPtr_)[setType]);
    fields[name] = f;
}


void Region::addScalarField
(
    Word setType,
    Word name,
    scalarField* f
)
{
    if(!scalarFieldTabPtr_)
    {
        scalarFieldTabPtr_ = new Table<Word, Table<Word, scalarField*>*>;
    }

    if(!(*scalarFieldTabPtr_)[setType])
    {
        (*scalarFieldTabPtr_)[setType] = new Table<Word, scalarField*>;
    }

    Table<Word, scalarField*>& fields = *((*scalarFieldTabPtr_)[setType]);
    fields[name] = f;
}


} // end namespace HSF
